/**
 * TypeScript interfaces for Knowledge Generation framework
 * Implements advanced prompting techniques for domain-specific architectural knowledge
 */
import { z } from 'zod';
export const KnowledgeItemSchema = z.object({
    category: z.enum([
        'best-practices',
        'design-patterns',
        'anti-patterns',
        'technology-specific',
        'performance-considerations',
        'security-guidelines',
        'scalability-patterns',
        'testing-strategies'
    ]),
    title: z.string(),
    content: z.string(),
    relevance: z.number().min(0).max(1),
    evidence: z.array(z.string()),
    tags: z.array(z.string()),
    sources: z.array(z.string()).optional(),
});
export const DomainKnowledgeSchema = z.object({
    domain: z.enum([
        'web-applications',
        'mobile-applications',
        'microservices',
        'database-design',
        'cloud-infrastructure',
        'devops-cicd',
        'security-patterns',
        'performance-optimization',
        'api-design',
        'data-architecture'
    ]),
    knowledge: z.array(KnowledgeItemSchema),
    confidence: z.number().min(0).max(1),
    timestamp: z.string(),
    sources: z.array(z.string()),
    metadata: z.object({
        generatedAt: z.string(),
        generationTime: z.number(),
        cacheKey: z.string(),
        domains: z.array(z.string()),
        confidence: z.number().min(0).max(1),
        version: z.string(),
    }),
});
export const KnowledgeGenerationConfigSchema = z.object({
    domains: z.array(z.string()).optional(),
    depth: z.enum(['basic', 'intermediate', 'advanced']).optional(),
    cacheEnabled: z.boolean().optional(),
    cacheTTL: z.number().optional(),
    securityValidation: z.boolean().optional(),
    customTemplates: z.array(z.any()).optional(),
    maxKnowledgeItems: z.number().optional(),
    maxTokens: z.number().optional(),
    relevanceThreshold: z.number().min(0).max(1).optional(),
    parallelGeneration: z.boolean().optional(),
});
// ============================================================================
// Export Schemas for Runtime Validation
// ============================================================================
export const ArchitecturalContextSchema = z.object({
    projectPath: z.string().optional(),
    technologies: z.array(z.string()).optional(),
    patterns: z.array(z.string()).optional(),
    existingAdrs: z.array(z.string()).optional(),
    projectType: z.string().optional(),
    teamSize: z.number().optional(),
    constraints: z.array(z.string()).optional(),
    goals: z.array(z.string()).optional(),
});
export const KnowledgeGenerationResultSchema = z.object({
    knowledgePrompt: z.object({
        prompt: z.string(),
        instructions: z.string(),
        context: z.any(),
    }),
    enhancedPrompt: z.object({
        prompt: z.string(),
        instructions: z.string(),
        context: z.any(),
    }).optional(),
    domainKnowledge: z.array(DomainKnowledgeSchema),
    cacheKey: z.string(),
    metadata: z.object({
        totalGenerationTime: z.number(),
        domainsProcessed: z.array(z.string()),
        knowledgeItemsGenerated: z.number(),
        cacheHits: z.number(),
        cacheMisses: z.number(),
        averageConfidence: z.number(),
        qualityScore: z.number(),
    }),
    securityCheck: z.object({
        contentSafety: z.boolean(),
        sourceReliability: z.number(),
        relevanceScore: z.number(),
        qualityScore: z.number(),
        warnings: z.array(z.string()),
        recommendations: z.array(z.string()),
        validationTime: z.number(),
    }).optional(),
});
//# sourceMappingURL=knowledge-generation.js.map
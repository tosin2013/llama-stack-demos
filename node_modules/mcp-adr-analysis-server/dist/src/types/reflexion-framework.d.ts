/**
 * TypeScript interfaces for Reflexion Framework
 * Implements Actor-Evaluator-Self-Reflection pattern for continuous learning
 */
import { z } from 'zod';
export interface PromptObject {
    prompt: string;
    instructions: string;
    context: any;
}
export type MemoryType = 'episodic' | 'semantic' | 'procedural' | 'meta' | 'feedback';
export type EvaluationCriterion = 'task-success' | 'quality' | 'efficiency' | 'accuracy' | 'completeness' | 'relevance' | 'clarity' | 'innovation';
export type ReflectionDepth = 'basic' | 'detailed' | 'comprehensive';
export type LearningPhase = 'memory-retrieval' | 'task-execution' | 'performance-evaluation' | 'self-reflection' | 'memory-integration';
export interface ReflexionConfig {
    memoryEnabled: boolean;
    maxMemoryEntries: number;
    reflectionDepth: ReflectionDepth;
    evaluationCriteria: EvaluationCriterion[];
    learningRate: number;
    memoryRetention: number;
    feedbackIntegration: boolean;
    autoCleanup: boolean;
    relevanceThreshold: number;
    confidenceThreshold: number;
}
export declare const ReflexionConfigSchema: z.ZodObject<{
    memoryEnabled: z.ZodBoolean;
    maxMemoryEntries: z.ZodNumber;
    reflectionDepth: z.ZodEnum<["basic", "detailed", "comprehensive"]>;
    evaluationCriteria: z.ZodArray<z.ZodEnum<["task-success", "quality", "efficiency", "accuracy", "completeness", "relevance", "clarity", "innovation"]>, "many">;
    learningRate: z.ZodNumber;
    memoryRetention: z.ZodNumber;
    feedbackIntegration: z.ZodBoolean;
    autoCleanup: z.ZodBoolean;
    relevanceThreshold: z.ZodNumber;
    confidenceThreshold: z.ZodNumber;
}, "strip", z.ZodTypeAny, {
    relevanceThreshold: number;
    evaluationCriteria: ("relevance" | "clarity" | "efficiency" | "task-success" | "quality" | "accuracy" | "completeness" | "innovation")[];
    memoryEnabled: boolean;
    maxMemoryEntries: number;
    reflectionDepth: "basic" | "detailed" | "comprehensive";
    learningRate: number;
    memoryRetention: number;
    feedbackIntegration: boolean;
    autoCleanup: boolean;
    confidenceThreshold: number;
}, {
    relevanceThreshold: number;
    evaluationCriteria: ("relevance" | "clarity" | "efficiency" | "task-success" | "quality" | "accuracy" | "completeness" | "innovation")[];
    memoryEnabled: boolean;
    maxMemoryEntries: number;
    reflectionDepth: "basic" | "detailed" | "comprehensive";
    learningRate: number;
    memoryRetention: number;
    feedbackIntegration: boolean;
    autoCleanup: boolean;
    confidenceThreshold: number;
}>;
export interface ToolReflexionConfig {
    toolName: string;
    taskTypes: string[];
    reflexionConfig: ReflexionConfig;
    customEvaluators?: CustomEvaluator[];
    memoryCategories?: string[];
    learningObjectives?: string[];
}
export interface TaskAttempt {
    attemptId: string;
    taskType: string;
    context: any;
    action: string;
    outcome: TaskOutcome;
    evaluation: EvaluationResult;
    reflection: SelfReflection;
    timestamp: string;
    metadata: AttemptMetadata;
    relatedMemories: string[];
    generatedMemories: string[];
}
export interface TaskOutcome {
    success: boolean;
    result: any;
    errors: string[];
    warnings: string[];
    executionTime: number;
    resourcesUsed: ResourceUsage;
    qualityMetrics: QualityMetrics;
    userFeedback?: UserFeedback;
}
export interface ResourceUsage {
    memoryAccessed: number;
    memoryCreated: number;
    processingTime: number;
    promptTokens: number;
    cacheHits: number;
    cacheMisses: number;
}
export interface QualityMetrics {
    accuracy: number;
    completeness: number;
    relevance: number;
    clarity: number;
    innovation: number;
    efficiency: number;
}
export interface AttemptMetadata {
    attemptNumber: number;
    previousAttempts: string[];
    improvementFromPrevious: number;
    strategiesUsed: string[];
    lessonsApplied: string[];
    challengesFaced: string[];
}
export interface EvaluationResult {
    overallScore: number;
    criteriaScores: Record<EvaluationCriterion, number>;
    feedback: EvaluationFeedback[];
    strengths: string[];
    weaknesses: string[];
    improvementAreas: string[];
    confidence: number;
    evaluationTime: number;
    evaluatorVersion: string;
    metadata: EvaluationMetadata;
}
export interface EvaluationFeedback {
    criterion: EvaluationCriterion;
    score: number;
    reasoning: string;
    suggestions: string[];
    examples?: string[];
    severity: 'low' | 'medium' | 'high' | 'critical';
}
export interface EvaluationMetadata {
    evaluatedAt: string;
    evaluationMethod: string;
    contextFactors: string[];
    biasChecks: BiasCheck[];
    reliability: number;
    comparativeAnalysis?: ComparativeAnalysis;
}
export interface BiasCheck {
    biasType: string;
    detected: boolean;
    severity: 'low' | 'medium' | 'high';
    mitigation: string;
}
export interface ComparativeAnalysis {
    comparedTo: string[];
    relativePerformance: number;
    improvementAreas: string[];
    regressionAreas: string[];
}
export interface CustomEvaluator {
    name: string;
    criterion: EvaluationCriterion;
    weight: number;
    evaluationPrompt: string;
    expectedOutputFormat: string;
    validationRules: ValidationRule[];
}
export interface ValidationRule {
    type: 'range' | 'format' | 'content' | 'logic';
    condition: string;
    errorMessage: string;
    severity: 'warning' | 'error';
}
export interface SelfReflection {
    reflectionId: string;
    reflectionText: string;
    lessonsLearned: LessonLearned[];
    actionableInsights: ActionableInsight[];
    futureStrategies: Strategy[];
    knowledgeGaps: KnowledgeGap[];
    confidenceLevel: number;
    applicability: string[];
    reflectionTime: number;
    metadata: ReflectionMetadata;
}
export interface LessonLearned {
    lesson: string;
    category: string;
    importance: 'low' | 'medium' | 'high' | 'critical';
    evidence: string[];
    applicableContexts: string[];
    confidence: number;
    generalizability: number;
}
export interface ActionableInsight {
    insight: string;
    action: string;
    priority: 'low' | 'medium' | 'high' | 'critical';
    timeframe: 'immediate' | 'short-term' | 'medium-term' | 'long-term';
    resources: string[];
    expectedImpact: number;
    riskLevel: 'low' | 'medium' | 'high';
}
export interface Strategy {
    strategy: string;
    description: string;
    applicableScenarios: string[];
    prerequisites: string[];
    expectedOutcomes: string[];
    riskFactors: string[];
    successMetrics: string[];
}
export interface KnowledgeGap {
    gap: string;
    category: string;
    impact: 'low' | 'medium' | 'high' | 'critical';
    learningPriority: number;
    suggestedResources: string[];
    estimatedLearningTime: string;
}
export interface ReflectionMetadata {
    reflectedAt: string;
    reflectionDepth: ReflectionDepth;
    triggerEvent: string;
    contextFactors: string[];
    emotionalState?: string;
    cognitiveLoad: number;
    reflectionQuality: number;
}
export interface ReflexionMemory {
    memoryId: string;
    memoryType: MemoryType;
    content: MemoryContent;
    relevanceScore: number;
    accessCount: number;
    lastAccessed: string;
    createdAt: string;
    expiresAt?: string;
    tags: string[];
    metadata: MemoryMetadata;
    relationships: MemoryRelationship[];
}
export interface MemoryContent {
    summary: string;
    details: string;
    context: any;
    lessons: string[];
    applicableScenarios: string[];
    relatedMemories: string[];
    evidence: string[];
    outcomes: string[];
    strategies: string[];
    warnings: string[];
}
export interface MemoryMetadata {
    source: string;
    quality: number;
    reliability: number;
    generalizability: number;
    updateCount: number;
    lastUpdated: string;
    category: string;
    subcategory?: string;
    importance: 'low' | 'medium' | 'high' | 'critical';
}
export interface MemoryRelationship {
    relatedMemoryId: string;
    relationshipType: 'similar' | 'contradicts' | 'builds-on' | 'prerequisite' | 'outcome';
    strength: number;
    description: string;
}
export interface MemoryQuery {
    taskType?: string;
    context?: any;
    keywords?: string[];
    memoryTypes?: MemoryType[];
    timeRange?: {
        start: string;
        end: string;
    };
    relevanceThreshold?: number;
    maxResults?: number;
    includeExpired?: boolean;
}
export interface MemorySearchResult {
    memories: ReflexionMemory[];
    totalFound: number;
    searchTime: number;
    relevanceScores: Record<string, number>;
    searchMetadata: SearchMetadata;
}
export interface SearchMetadata {
    searchQuery: MemoryQuery;
    searchStrategy: string;
    indexesUsed: string[];
    cacheHits: number;
    searchQuality: number;
}
export interface LearningProgress {
    taskType: string;
    totalAttempts: number;
    successRate: number;
    averageScore: number;
    improvementTrend: number;
    lastImprovement: string;
    keyLessons: string[];
    persistentIssues: string[];
    nextFocusAreas: string[];
    learningVelocity: number;
    plateauDetection: PlateauAnalysis;
    metadata: LearningMetadata;
}
export interface PlateauAnalysis {
    isOnPlateau: boolean;
    plateauDuration: number;
    plateauConfidence: number;
    suggestedInterventions: string[];
    alternativeApproaches: string[];
}
export interface LearningMetadata {
    trackingStarted: string;
    lastUpdated: string;
    dataQuality: number;
    sampleSize: number;
    confidenceInterval: number;
    statisticalSignificance: number;
    trendAnalysis: TrendAnalysis;
}
export interface TrendAnalysis {
    shortTermTrend: number;
    mediumTermTrend: number;
    longTermTrend: number;
    volatility: number;
    predictability: number;
}
export interface ReflexionResult {
    enhancedPrompt: PromptObject;
    taskAttempt: TaskAttempt;
    learningOutcome: LearningOutcome;
    memoryUpdates: MemoryUpdate[];
    performanceMetrics: ReflexionPerformanceMetrics;
    recommendations: string[];
}
export interface LearningOutcome {
    lessonsLearned: number;
    memoriesCreated: number;
    memoriesUpdated: number;
    improvementAchieved: number;
    knowledgeGapsIdentified: number;
    strategiesRefined: number;
    confidenceChange: number;
}
export interface MemoryUpdate {
    memoryId: string;
    updateType: 'create' | 'update' | 'strengthen' | 'weaken' | 'expire';
    changes: string[];
    reason: string;
    impact: number;
}
export interface ReflexionPerformanceMetrics {
    totalReflexionTime: number;
    memoryRetrievalTime: number;
    evaluationTime: number;
    reflectionTime: number;
    memoryIntegrationTime: number;
    memoriesAccessed: number;
    memoriesCreated: number;
    learningEfficiency: number;
    resourceUtilization: number;
}
export interface UserFeedback {
    rating: number;
    comments: string;
    categories: string[];
    helpfulness: number;
    accuracy: number;
    suggestions: string[];
    submittedAt: string;
    userId?: string;
}
export declare const TaskAttemptSchema: z.ZodObject<{
    attemptId: z.ZodString;
    taskType: z.ZodString;
    context: z.ZodAny;
    action: z.ZodString;
    outcome: z.ZodObject<{
        success: z.ZodBoolean;
        result: z.ZodAny;
        errors: z.ZodArray<z.ZodString, "many">;
        warnings: z.ZodArray<z.ZodString, "many">;
        executionTime: z.ZodNumber;
        resourcesUsed: z.ZodObject<{
            memoryAccessed: z.ZodNumber;
            memoryCreated: z.ZodNumber;
            processingTime: z.ZodNumber;
            promptTokens: z.ZodNumber;
            cacheHits: z.ZodNumber;
            cacheMisses: z.ZodNumber;
        }, "strip", z.ZodTypeAny, {
            cacheHits: number;
            cacheMisses: number;
            memoryAccessed: number;
            memoryCreated: number;
            processingTime: number;
            promptTokens: number;
        }, {
            cacheHits: number;
            cacheMisses: number;
            memoryAccessed: number;
            memoryCreated: number;
            processingTime: number;
            promptTokens: number;
        }>;
        qualityMetrics: z.ZodObject<{
            accuracy: z.ZodNumber;
            completeness: z.ZodNumber;
            relevance: z.ZodNumber;
            clarity: z.ZodNumber;
            innovation: z.ZodNumber;
            efficiency: z.ZodNumber;
        }, "strip", z.ZodTypeAny, {
            relevance: number;
            clarity: number;
            efficiency: number;
            accuracy: number;
            completeness: number;
            innovation: number;
        }, {
            relevance: number;
            clarity: number;
            efficiency: number;
            accuracy: number;
            completeness: number;
            innovation: number;
        }>;
    }, "strip", z.ZodTypeAny, {
        warnings: string[];
        success: boolean;
        errors: string[];
        executionTime: number;
        resourcesUsed: {
            cacheHits: number;
            cacheMisses: number;
            memoryAccessed: number;
            memoryCreated: number;
            processingTime: number;
            promptTokens: number;
        };
        qualityMetrics: {
            relevance: number;
            clarity: number;
            efficiency: number;
            accuracy: number;
            completeness: number;
            innovation: number;
        };
        result?: any;
    }, {
        warnings: string[];
        success: boolean;
        errors: string[];
        executionTime: number;
        resourcesUsed: {
            cacheHits: number;
            cacheMisses: number;
            memoryAccessed: number;
            memoryCreated: number;
            processingTime: number;
            promptTokens: number;
        };
        qualityMetrics: {
            relevance: number;
            clarity: number;
            efficiency: number;
            accuracy: number;
            completeness: number;
            innovation: number;
        };
        result?: any;
    }>;
    evaluation: z.ZodObject<{
        overallScore: z.ZodNumber;
        criteriaScores: z.ZodRecord<z.ZodString, z.ZodNumber>;
        feedback: z.ZodArray<z.ZodAny, "many">;
        strengths: z.ZodArray<z.ZodString, "many">;
        weaknesses: z.ZodArray<z.ZodString, "many">;
        improvementAreas: z.ZodArray<z.ZodString, "many">;
        confidence: z.ZodNumber;
        evaluationTime: z.ZodNumber;
        evaluatorVersion: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        confidence: number;
        evaluationTime: number;
        feedback: any[];
        overallScore: number;
        criteriaScores: Record<string, number>;
        strengths: string[];
        weaknesses: string[];
        improvementAreas: string[];
        evaluatorVersion: string;
    }, {
        confidence: number;
        evaluationTime: number;
        feedback: any[];
        overallScore: number;
        criteriaScores: Record<string, number>;
        strengths: string[];
        weaknesses: string[];
        improvementAreas: string[];
        evaluatorVersion: string;
    }>;
    reflection: z.ZodObject<{
        reflectionId: z.ZodString;
        reflectionText: z.ZodString;
        lessonsLearned: z.ZodArray<z.ZodAny, "many">;
        actionableInsights: z.ZodArray<z.ZodAny, "many">;
        futureStrategies: z.ZodArray<z.ZodAny, "many">;
        knowledgeGaps: z.ZodArray<z.ZodAny, "many">;
        confidenceLevel: z.ZodNumber;
        applicability: z.ZodArray<z.ZodString, "many">;
        reflectionTime: z.ZodNumber;
    }, "strip", z.ZodTypeAny, {
        reflectionId: string;
        reflectionText: string;
        lessonsLearned: any[];
        actionableInsights: any[];
        futureStrategies: any[];
        knowledgeGaps: any[];
        confidenceLevel: number;
        applicability: string[];
        reflectionTime: number;
    }, {
        reflectionId: string;
        reflectionText: string;
        lessonsLearned: any[];
        actionableInsights: any[];
        futureStrategies: any[];
        knowledgeGaps: any[];
        confidenceLevel: number;
        applicability: string[];
        reflectionTime: number;
    }>;
    timestamp: z.ZodString;
    metadata: z.ZodAny;
    relatedMemories: z.ZodArray<z.ZodString, "many">;
    generatedMemories: z.ZodArray<z.ZodString, "many">;
}, "strip", z.ZodTypeAny, {
    timestamp: string;
    evaluation: {
        confidence: number;
        evaluationTime: number;
        feedback: any[];
        overallScore: number;
        criteriaScores: Record<string, number>;
        strengths: string[];
        weaknesses: string[];
        improvementAreas: string[];
        evaluatorVersion: string;
    };
    outcome: {
        warnings: string[];
        success: boolean;
        errors: string[];
        executionTime: number;
        resourcesUsed: {
            cacheHits: number;
            cacheMisses: number;
            memoryAccessed: number;
            memoryCreated: number;
            processingTime: number;
            promptTokens: number;
        };
        qualityMetrics: {
            relevance: number;
            clarity: number;
            efficiency: number;
            accuracy: number;
            completeness: number;
            innovation: number;
        };
        result?: any;
    };
    attemptId: string;
    taskType: string;
    action: string;
    reflection: {
        reflectionId: string;
        reflectionText: string;
        lessonsLearned: any[];
        actionableInsights: any[];
        futureStrategies: any[];
        knowledgeGaps: any[];
        confidenceLevel: number;
        applicability: string[];
        reflectionTime: number;
    };
    relatedMemories: string[];
    generatedMemories: string[];
    metadata?: any;
    context?: any;
}, {
    timestamp: string;
    evaluation: {
        confidence: number;
        evaluationTime: number;
        feedback: any[];
        overallScore: number;
        criteriaScores: Record<string, number>;
        strengths: string[];
        weaknesses: string[];
        improvementAreas: string[];
        evaluatorVersion: string;
    };
    outcome: {
        warnings: string[];
        success: boolean;
        errors: string[];
        executionTime: number;
        resourcesUsed: {
            cacheHits: number;
            cacheMisses: number;
            memoryAccessed: number;
            memoryCreated: number;
            processingTime: number;
            promptTokens: number;
        };
        qualityMetrics: {
            relevance: number;
            clarity: number;
            efficiency: number;
            accuracy: number;
            completeness: number;
            innovation: number;
        };
        result?: any;
    };
    attemptId: string;
    taskType: string;
    action: string;
    reflection: {
        reflectionId: string;
        reflectionText: string;
        lessonsLearned: any[];
        actionableInsights: any[];
        futureStrategies: any[];
        knowledgeGaps: any[];
        confidenceLevel: number;
        applicability: string[];
        reflectionTime: number;
    };
    relatedMemories: string[];
    generatedMemories: string[];
    metadata?: any;
    context?: any;
}>;
//# sourceMappingURL=reflexion-framework.d.ts.map